// Generated by CoffeeScript 1.9.1
(function() {
  var Github, async, func, github, http, method, querystring, ref, ref1, version;

  http = require("scoped-http-client");

  async = require("async");

  querystring = require("querystring");

  version = require("../package.json")["version"];

  Github = (function() {
    function Github(logger, options1) {
      this.logger = logger;
      this.options = options1;
      this.requestQueue = async.queue((function(_this) {
        return function(task, cb) {
          return task.run(cb);
        };
      })(this), this._opt("concurrentRequests"));
    }

    Github.prototype.withOptions = function(specialOptions) {
      var g, k, newOpts, ref, v;
      newOpts = {};
      ref = this.options;
      for (k in ref) {
        v = ref[k];
        newOpts[k] = v;
      }
      for (k in specialOptions) {
        v = specialOptions[k];
        newOpts[k] = v;
      }
      g = new Github(this.logger, newOpts);
      g.requestQueue = this.requestQueue;
      return g;
    };

    Github.prototype.qualified_repo = function(repo) {
      var user;
      if (repo == null) {
        if ((repo = this._opt("defaultRepo")) == null) {
          this.logger.error("Default Github repo not specified");
          return null;
        }
      }
      repo = repo.toLowerCase();
      if (repo.indexOf("/") !== -1) {
        return repo;
      }
      if ((user = this._opt("defaultUser")) == null) {
        this.logger.error("Default Github user not specified");
        return repo;
      }
      return user + "/" + repo;
    };

    Github.prototype.request = function(verb, url, data, cb) {
      var args, oauth_token, ref, req, task, url_api_base;
      if (cb == null) {
        ref = [data, null], cb = ref[0], data = ref[1];
      }
      url_api_base = this._opt("apiRoot");
      if (url.slice(0, 4) !== "http") {
        if (url[0] !== "/") {
          url = "/" + url;
        }
        url = "" + url_api_base + url;
      }
      req = http.create(url).header("Accept", "application/vnd.github." + (this._opt("apiVersion")) + "+json");
      req = req.header("User-Agent", "GitHubot/" + version);
      oauth_token = this._opt("token");
      if (oauth_token != null) {
        req = req.header("Authorization", "token " + oauth_token);
      }
      args = [];
      if (data != null) {
        args.push(JSON.stringify(data));
      }
      if (verb === "DELETE" && (data == null)) {
        args.push("");
      }
      task = {
        run: function(cb) {
          return req[verb.toLowerCase()].apply(req, args)(cb);
        }
      };
      return this.requestQueue.push(task, (function(_this) {
        return function(err, res, body) {
          var e, ref1, responseData;
          if (err != null) {
            return _this._errorHandler({
              statusCode: res != null ? res.statusCode : void 0,
              body: res != null ? res.body : void 0,
              error: err
            });
          }
          try {
            if (body) {
              responseData = JSON.parse(body);
            }
          } catch (_error) {
            e = _error;
            return _this._errorHandler({
              statusCode: res.statusCode,
              body: body,
              error: "Could not parse response: " + body
            });
          }
          if ((200 <= (ref1 = res.statusCode) && ref1 < 300)) {
            return cb(responseData);
          } else {
            return _this._errorHandler({
              statusCode: res.statusCode,
              body: body,
              error: responseData.message
            });
          }
        };
      })(this));
    };

    Github.prototype.get = function(url, data, cb) {
      var ref;
      if (cb == null) {
        ref = [data, null], cb = ref[0], data = ref[1];
      }
      if (data != null) {
        url += "?" + querystring.stringify(data);
      }
      return this.request("GET", url, cb);
    };

    Github.prototype.post = function(url, data, cb) {
      return this.request("POST", url, data, cb);
    };

    Github.prototype["delete"] = function(url, cb) {
      return this.request("DELETE", url, null, cb);
    };

    Github.prototype.put = function(url, data, cb) {
      return this.request("PUT", url, data, cb);
    };

    Github.prototype.patch = function(url, data, cb) {
      return this.request("PATCH", url, data, cb);
    };

    Github.prototype.handleErrors = function(callback) {
      return this.options.errorHandler = callback;
    };

    Github.prototype._loggerErrorHandler = function(response) {
      var message;
      message = response.error;
      if (response.statusCode != null) {
        message = response.statusCode + " " + message;
      }
      return this.logger.error(message);
    };

    Github.prototype._errorHandler = function(response) {
      var base;
      if (typeof (base = this.options).errorHandler === "function") {
        base.errorHandler(response);
      }
      return this._loggerErrorHandler(response);
    };

    Github.prototype.branches = require('./branches');

    Github.prototype.deployments = require('./deployments');

    Github.prototype._opt = function(optName) {
      var ref;
      if (this.options == null) {
        this.options = {};
      }
      return (ref = this.options[optName]) != null ? ref : this._optFromEnv(optName);
    };

    Github.prototype._optFromEnv = function(optName) {
      var ref, ref1, ref2;
      switch (optName) {
        case "token":
          return process.env.HUBOT_GITHUB_TOKEN;
        case "concurrentRequests":
          return (ref = process.env.HUBOT_CONCURRENT_REQUESTS) != null ? ref : 20;
        case "defaultRepo":
          return process.env.HUBOT_GITHUB_REPO;
        case "defaultUser":
          return process.env.HUBOT_GITHUB_USER;
        case "apiRoot":
          return (ref1 = process.env.HUBOT_GITHUB_API) != null ? ref1 : "https://api.github.com";
        case "apiVersion":
          return (ref2 = process.env.HUBOT_GITHUB_API_VERSION) != null ? ref2 : "v3";
        default:
          return null;
      }
    };

    return Github;

  })();

  module.exports = github = function(robot, options) {
    if (options == null) {
      options = {};
    }
    return new Github(robot.logger, options);
  };

  ref = Github.prototype;
  for (method in ref) {
    func = ref[method];
    github[method] = func;
  }

  github.logger = {
    error: function(msg) {
      return console.error("ERROR: " + msg);
    },
    debug: function() {}
  };

  github.requestQueue = async.queue((function(_this) {
    return function(task, cb) {
      return task.run(cb);
    };
  })(this), (ref1 = process.env.HUBOT_CONCURRENT_REQUESTS) != null ? ref1 : 20);

}).call(this);
